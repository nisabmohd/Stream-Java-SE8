import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Main {
    static List<Movie> list;

    static {
        list = List.of(
                new Movie("en", "Shawshank Redemption", 278, 9.3f),
                new Movie("en", "Whiplash", 244786, 7.3f),
                new Movie("en", "The Godfather", 238, 9.1f),
                new Movie("ja", "千と千尋の神隠し", 129, 7.9f)
        );
    }

    public static void main(String[] args) {

        //Intermediate operation :
        // The method return stream itself then called intermediate operation

        // Terminal Operation :
        // The method return primitive not stream

        //The main difference between intermediate and terminal operations is that intermediate operations return a stream as a result and
        // terminal operations return non-stream values like primitive or object or collection or may not return anything.

        // forEach(Consumer<? super T> action)
        // Performs an action for each element of this stream.
        list.stream().forEach((item) -> System.out.println(item));

        // filter method
        // Stream<T> filter(Predicate<? super T> predicate)
        // Returns a stream consisting of the elements of this stream that match the given predicate.
        List<Movie> filtered = list.stream().filter((movie) -> movie.getRatings() > 9).toList();
        System.out.println(filtered);

        // <R> Stream<R> map(Function<? super T,? extends R> mapper)
        // Returns a stream consisting of the results of applying the given function to the elements of this stream.
        List<Long> ids = list.stream().map((item) -> item.getId()).toList();
        System.out.println(filtered);


        // concat(Stream<? extends T> a, Stream<? extends T> b)
        // Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
        List<Movie> temp = List.of(new Movie("en", "Temp", 45, 1.8f));
        List<Movie> concatenated = Stream.concat(temp.stream(), filtered.stream()).toList();
        System.out.println(concatenated);

        //collect
        // maps through each data and return all ratings
        // converts to collection from stream
        List<Float> ratings = list.stream().map((movie) -> movie.getRatings()).collect(Collectors.toList()); // toSet() also
        System.out.println(ratings);

        // findFirst
        // Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.
        Movie first = list.stream().filter(item -> item.getId() == 278).findFirst().orElse(null);
        System.out.println(first);

        // short circuit operations
        List<Movie> shorthand = list.stream().skip(1).limit(1).toList();
        System.out.println(shorthand);

        // of(T t)
        // Returns a sequential Stream containing a single element.
        Stream t = Stream.of(5);

        // 	generate(Supplier<T> s)
        // Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
        // limit can be use to make your infinite data to finite
        Stream.generate(Math::random).limit(5).forEach(item -> System.out.println(item));


        // sorted(Comparator)
        List<Movie> sorted = list.stream().sorted((o1, o2) -> -Float.compare(o1.getRatings(), o2.getRatings())).toList();
        System.out.println(sorted);

        // min and max
        // Optional<T> max(Comparator<? super T> comparator)
        // Returns the maximum element of this stream according to the provided Comparator.
        // Optional<T> min(Comparator<? super T> comparator)
        // Returns the minimum element of this stream according to the provided Comparator.
        Movie highestRating = list.stream().max((o1, o2) -> Float.compare(o1.getRatings(), o2.getRatings())).orElseThrow(NoSuchElementException::new);
        System.out.println(highestRating);
        Movie lowestRating = list.stream().min((o1, o2) -> Float.compare(o1.getRatings(), o2.getRatings())).orElseThrow(NoSuchElementException::new);
        System.out.println(lowestRating);

        // reduce(T identity, BinaryOperator<T> accumulator)
        // Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.
        Float ratingsSum = list.stream().map(item -> item.getRatings()).reduce(0.0f, (aFloat, aFloat2) -> aFloat + aFloat2);
        System.out.println(ratingsSum);

        //	anyMatch(Predicate<? super T> predicate)
        // Returns whether any elements of this stream match the provided predicate.
        boolean present = list.stream().anyMatch(movie -> movie.getId() == 278);
        System.out.println(present);

        // allMatch(Predicate<? super T> predicate)
        // Returns whether all elements of this stream match the provided predicate.
        boolean allEnglish = list.stream().allMatch(movie -> movie.getLanguage() == "en");
        System.out.println(allEnglish);

        // count()
        // Returns the count of elements in this stream.
        Long ans = list.stream().filter(movie -> movie.getLanguage() == "ja").count();
        System.out.println(ans);

        // streams with Map
        Map<Integer, Integer> map = new HashMap<>();
        map.put(1, 10);
        map.put(2, 20);
        map.put(3, 30);
        List<Map.Entry<Integer, Integer>> mapEntryList = new ArrayList<>(map.entrySet());
        List<Map.Entry<Integer, Integer>> filteredMapEntry = mapEntryList.stream().filter(item -> item.getValue() == 30).toList();
        System.out.println(filteredMapEntry);

        // streams with Set
        Set<Integer> set = new HashSet<>(Arrays.asList(1,2,3,45));
        Set<Integer> dupset=set.stream().map(item->item*10).collect(Collectors.toSet());
        System.out.println(dupset);

        // streams with PriorityQueue
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        pq.add(1);
        pq.add(31);
        pq.add(100);
        pq.add(814);
        pq.add(14);
        pq.stream().forEachOrdered(item-> System.out.print(item+" "));

    }
}