import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Main {
    static List<Movie> list;

    static {
        list = List.of(
                new Movie("en", "Shawshank Redemption", 278, 9.3f),
                new Movie("en", "Whiplash", 244786, 7.3f),
                new Movie("en", "The Godfather", 238, 9.1f),
                new Movie("ja", "千と千尋の神隠し", 129, 7.9f)
        );
    }

    public static void main(String[] args) {

        //Intermediate operation :
        // The method return stream itself then called intermediate operation

        // Terminal Operation :
        // The method return primitive not stream

        //The main difference between intermediate and terminal operations is that intermediate operations return a stream as a result and
        // terminal operations return non-stream values like primitive or object or collection or may not return anything.

        //forEach
        list.stream().forEach((item) -> System.out.println(item));

        // filter method
        // Stream<T> filter(Predicate<? super T> predicate)
        // Returns a stream consisting of the elements of this stream that match the given predicate.
        List<Movie> filtered = list.stream().filter((movie) -> movie.getRatings() > 9).toList();
        System.out.println(filtered);

        // map
        // <R> Stream<R> map(Function<? super T,? extends R> mapper)
        // Returns a stream consisting of the results of applying the given function to the elements of this stream.
        List<Long> ids = list.stream().map((item) -> item.getId()).toList();
        System.out.println(filtered);

        // concat
        // concat(Stream<? extends T> a, Stream<? extends T> b)
        // Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
        List<Movie> temp = List.of(new Movie("en", "Temp", 45, 1.8f));
        List<Movie> concatenated = Stream.concat(temp.stream(), filtered.stream()).toList();
        System.out.println(concatenated);

        //collect
        // maps through each data and return all ratings
        // converts to collection from stream
        List<Float> ratings = list.stream().map((movie) -> movie.getRatings()).collect(Collectors.toList()); // toSet() also
        System.out.println(ratings);

        // findFirst
        // Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.
        Movie first = list.stream().filter(item -> item.getId() == 278).findFirst().orElse(null);
        System.out.println(first);

        // flatMap (Function<? super T,? extends Stream<? extends R>> mapper)
        // Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying
        // the provided mapping function to each element.


        // short circuit operations
        List<Movie> shorthand = list.stream().skip(1).limit(1).toList();
        System.out.println(shorthand);

        // of(T t)
        // Returns a sequential Stream containing a single element.
        Stream t = Stream.of(5);

        // 	generate(Supplier<T> s)
        // Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
        // limit can be use to make your infinite data to finite
        Stream.generate(Math::random).limit(5).forEach(item -> System.out.println(item));


        // sorted(Comparator)
        List<Movie> sorted = list.stream().sorted((o1, o2) -> -Float.compare(o1.getRatings(), o2.getRatings())).toList();
        System.out.println(sorted);

        // min and max
        // Optional<T> max(Comparator<? super T> comparator)
        // Returns the maximum element of this stream according to the provided Comparator.
        // Optional<T> min(Comparator<? super T> comparator)
        // Returns the minimum element of this stream according to the provided Comparator.
        Movie highestRating = list.stream().max((o1, o2) -> Float.compare(o1.getRatings(), o2.getRatings())).orElseThrow(NoSuchElementException::new);
        System.out.println(highestRating);
        Movie lowestRating = list.stream().min((o1, o2) -> Float.compare(o1.getRatings(), o2.getRatings())).orElseThrow(NoSuchElementException::new);
        System.out.println(lowestRating);

        // reduce(T identity, BinaryOperator<T> accumulator)
        // Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.
        Float ratingsSum=list.stream().map(item -> item.getRatings()).reduce(0.0f, (aFloat, aFloat2) -> aFloat + aFloat2);
        System.out.println(ratingsSum);

        //	anyMatch(Predicate<? super T> predicate)
        // Returns whether any elements of this stream match the provided predicate.
        boolean present=list.stream().anyMatch(movie -> movie.getId()==278);
        System.out.println(present);

        // allMatch(Predicate<? super T> predicate)
        // Returns whether all elements of this stream match the provided predicate.
        boolean allEnglish=list.stream().allMatch(movie -> movie.getLanguage()=="en");
        System.out.println(allEnglish);

        // count()
        // Returns the count of elements in this stream.
        Long ans=list.stream().filter(movie -> movie.getLanguage()=="ja").count();
        System.out.println(ans);
    }
}